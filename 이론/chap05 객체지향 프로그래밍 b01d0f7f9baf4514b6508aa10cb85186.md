# chap05 객체지향 프로그래밍

# this

```java
GoodsStock(String goodscode, int stockNum) {
	this.goodsCode = goodsCode;
	this.stockNum = stockNum;
}
```

this를 붙여주면 레퍼런스가 받아오는 파라미터를 잘 정리 구분? 가능하다?

```java
Goodstock obj;
obj = new Goodstock();
```

하나의 패키지안에 클래스들은  연동이된다.

위 코드같은 것은 위위 코드 처럼 저렇게 () 안에 변수들이 지정되면 무조건 저렇게 써줘야 인정된다.

만일 저 위위 코드를 지워주면 2번째 코드는 빨간줄 없이 잘 작동한다.

## 둘 이상의 생성자

회원가입 : 필수 항목과 선택 항목이 나뉘어져있다. 이때 여러개의 생성자가 필요하다!

누구는 필수만 입력하고 누구는 추가로 더 친절하게 입력할 것이기 때문이다. 잘 이해 안되면 밑에 사진을 보자.

생성자를 만들때 지켜줘야하는 두 가지 조건

1. 생성자의 이름은 클래스의 이름과 같아야한다
2. 반환형이 없다.
    - 생성자를 어떻게 구별하냐?
    - 매개변수의 타입, 수에 따라 구별한다
    

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled.png)

```java
SubscriberInfo obj1, obj2;
obj1 = new SubscriberInfo("연흥부", "poorman", "zebi"); 
obj2 = new SubscriberInfo("연놀부", "richman", "money",
"02-000-0000", "타워팰리스");
```

이런식으로 적용 가능하다.

그리고 중요한것은 위에 처럼 이렇게 사용한뒤 밑에 저걸 잡았으면 써야하는데 어떻게 쓰냐면

```java
static void printSubscriberInfo(SubscriberInfo obj) {
printSubscriberInfo(obj2);
	System.out.println("이름:" + obj.name);
	System.out.println("아이디:" + obj.id);
	System.out.println("패스워드:" + obj.password);
	System.out.println("전화번호:" + obj.phoneNo);
	System.out.println("주소:" + obj.address);
	System.out.println();
```

이렇게 하면 위에서 받은 모든 obj에 대해 출력한다.

## 생성자가 겹치는게 싫다.

위에 3개 받아오고 변수는 5 적고 밑에 

this (name,id,password); 을 해주면 다 받아와준다.

## 생성자는 다 똑같은 값으로 초기화 된다.

# 02 필드와 메소드

필드 생성자 메소드 순서가 다 바껴도 상관없는데 권장하진 않는다.

필드 ⇒ 메소드 이순서로 가는게 좋다

메소드의 정의는 인스턴스에 저장이 안된다.

인스턴스에는 값만 주어져있고 다만 클래스안에는 메소드가 있기 때문에 작동은 된다.

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled%201.png)

이렇게 하지말고 그냥 필드에 초기화 다 시켜놓고 시작해라!

# 메소드 오버로딩

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled%202.png)

# 03 클래스의 정적 구성 요소

- 클래스의 정적 구성 요소
    - 객체가 아니라 클래스 자체에 속하는 필드, 메소드 등의 구성 요소
    - static 키워드를 사용하여 선언
    - 예) 정적 필드, 정적 메소드, 정적 초기화 블록

필드 - 클래스 내 인스턴스의 값을 저장

ex) 원 넓이 계산하는데 반지름은 각각 달라지지만 파이의 값은 고정 되있어야한다 이럴 때 static을 쓴다

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled%203.png)

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled%204.png)

이렇게 되면 

obj 1 total = 10,  grandTotal  =10

obj2 total  = 20  grandTotal = 10 +20

grandTotal은 각각 인스턴스가 없지만 클래스내에서 고정을 시켜 버렸기 때문에 인스턴스가 없어도 이용가능하다.

static 접근은 레퍼런스로 접근이 아니라 그냥 클래스안에서 접근하는것이다.

## 정적 메소드

연산을 목적으로 하는 메소드에 사용한다.

# 04 클래스의 상속

상속 : 기존 클래스를 확장해서 새로운 클래스를 만드는 기술

![Untitled](chap05%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b01d0f7f9baf4514b6508aa10cb85186/Untitled%205.png)